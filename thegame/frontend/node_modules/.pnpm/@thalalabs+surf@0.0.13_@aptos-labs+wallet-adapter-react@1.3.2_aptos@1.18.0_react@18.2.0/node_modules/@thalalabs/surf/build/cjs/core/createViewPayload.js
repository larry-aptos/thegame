"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createViewPayload = void 0;
const aptos_1 = require("aptos");
const ensureTypes_js_1 = require("../ensureTypes.js");
function createViewPayload(abi, payload) {
    const fnAbi = abi.exposed_functions.filter((f) => f.name === payload.function)[0];
    const type_arguments = payload.type_arguments;
    const val_arguments = payload.arguments;
    if (fnAbi === undefined)
        throw new Error(`Function ${payload.function} not found in ABI`);
    if (fnAbi.params.length !== val_arguments.length)
        throw new Error(`Function ${payload.function} expects ${fnAbi.params.length} arguments, but ${payload.arguments.length} were provided`);
    if (fnAbi.generic_type_params.length !== type_arguments.length)
        throw new Error(`Function ${payload.function} expects ${fnAbi.generic_type_params.length} type arguments, but ${payload.type_arguments.length} were provided`);
    const args = fnAbi.params.map((type, i) => {
        const arg = payload.arguments[i];
        if (['u8', 'u16', 'u32'].includes(type)) {
            return (0, ensureTypes_js_1.ensureNumber)(arg);
        }
        else if (['u64', 'u128', 'u256'].includes(type)) {
            if (!arg?.toString) {
                throw new Error(`Expecting a bigint, but got ${arg}`);
            }
            return arg.toString();
        }
        else if (type.includes('vector')) {
            return encodeVector(type, arg);
        }
        else {
            return arg;
        }
    });
    const decoders = fnAbi.return.map((type) => {
        if (['u64', 'u128', 'u256'].includes(type)) {
            return decodeBigint;
        }
        else if (type.includes('vector')) {
            return (value) => decodeVector(type, value);
        }
        else {
            return null;
        }
    });
    return {
        viewRequest: {
            function: `${abi.address}::${abi.name}::${payload.function}`,
            arguments: args,
            type_arguments: payload.type_arguments,
        },
        decoders,
    };
}
exports.createViewPayload = createViewPayload;
function decodeBigint(value) {
    return BigInt(value);
}
function decodeVector(type, value) {
    const regex = /vector<([^]+)>/;
    const match = type.match(regex);
    if (!match) {
        throw new Error(`Unsupported type: ${type}`);
    }
    const innerType = match[1];
    if (['address', 'bool', 'u8', 'u16', 'u32'].includes(innerType)) {
        return value;
    }
    else if (['u64', 'u128', 'u256'].includes(innerType)) {
        return value.map((v) => BigInt(v));
    }
    else {
        return value;
    }
}
function encodeVector(type, value) {
    const regex = /vector<([^]+)>/;
    const match = type.match(regex);
    if (!match) {
        throw new Error(`Unsupported type: ${type}`);
    }
    const innerType = match[1];
    if (innerType === 'u8') {
        return aptos_1.HexString.fromUint8Array(new Uint8Array(value.map((v) => {
            const result = (0, ensureTypes_js_1.ensureNumber)(v);
            if (result < 0 || result > 255)
                throw new Error(`Invalid u8 value: ${result}`);
            return result;
        }))).hexString;
    }
    else if (['bool', 'u16', 'u32'].includes(innerType)) {
        return value;
    }
    else if (['u64', 'u128', 'u256'].includes(innerType)) {
        return value.map((v) => v.toString());
    }
    else {
        return value;
    }
}
//# sourceMappingURL=createViewPayload.js.map