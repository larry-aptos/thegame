"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createEntryPayload = void 0;
const aptos_1 = require("aptos");
const ensureTypes_js_1 = require("../ensureTypes.js");
function createEntryPayload(abi, payload) {
    const fnAbi = abi.exposed_functions.filter((f) => f.name === payload.function)[0];
    const typeArguments = payload.type_arguments;
    const valArguments = payload.arguments;
    const abiArgs = fnAbi.params[0] === '&signer'
        ? fnAbi.params.slice(1)
        : fnAbi.params;
    if (fnAbi === undefined)
        throw new Error(`Function ${payload.function} not found in ABI`);
    if (abiArgs.length !== valArguments.length)
        throw new Error(`Function ${payload.function} expects ${fnAbi.params.length} arguments, but ${payload.arguments.length} were provided`);
    if (fnAbi.generic_type_params.length !== typeArguments.length)
        throw new Error(`Function ${payload.function} expects ${fnAbi.generic_type_params.length} type arguments, but ${payload.type_arguments.length} were provided`);
    return {
        rawPayload: {
            ...payload,
            function: `${abi.address}::${abi.name}::${payload.function}`,
        },
        entryRequest: aptos_1.TxnBuilderTypes.EntryFunction.natural(`${abi.address}::${abi.name}`, payload.function, typeArguments
            .map((arg) => {
            const typeTagStruct = new aptos_1.TypeTagParser(arg).parseTypeTag();
            return new aptos_1.TxnBuilderTypes.TypeTagStruct(new aptos_1.TxnBuilderTypes.StructTag(typeTagStruct.value.address, typeTagStruct.value.module_name, typeTagStruct.value.name, typeTagStruct.value.type_args));
        }), valArguments.map((arg, i) => {
            const type = abiArgs[i];
            const serializer = new aptos_1.BCS.Serializer();
            argToBCS(type, arg, serializer);
            return serializer.getBytes();
        })),
    };
}
exports.createEntryPayload = createEntryPayload;
function argToBCS(type, arg, serializer) {
    const vectorRegex = /vector<([^]+)>/;
    const vectorMatch = type.match(vectorRegex);
    if (vectorMatch) {
        const innerType = vectorMatch[1];
        if (innerType === 'u8') {
            if (arg instanceof Uint8Array) {
                serializer.serializeBytes(arg);
                return;
            }
            if (typeof arg === 'string') {
                serializer.serializeStr(arg);
                return;
            }
        }
        if (!Array.isArray(arg)) {
            throw new Error('Invalid vector args.');
        }
        serializer.serializeU32AsUleb128(arg.length);
        arg.forEach((arg) => argToBCS(innerType, arg, serializer));
        return;
    }
    const objectRegex = /0x1::object::Object<([^]+)>/;
    const objectMatch = type.match(objectRegex);
    if (objectMatch) {
        aptos_1.TxnBuilderTypes.AccountAddress.fromHex(arg).serialize(serializer);
        return;
    }
    const optionRegex = /0x1::option::Option<([^]+)>/;
    const optionMatch = type.match(optionRegex);
    if (optionMatch) {
        const innerType = optionMatch[1];
        serializer.serializeU32AsUleb128(arg.length);
        if (!(arg instanceof Array) || arg.length > 1) {
            throw new Error('Invalid input value for 0x1::option::Option.');
        }
        arg.forEach((arg) => argToBCS(innerType, arg, serializer));
        return;
    }
    switch (type) {
        case 'bool':
            serializer.serializeBool((0, ensureTypes_js_1.ensureBoolean)(arg));
            break;
        case 'address':
            aptos_1.TxnBuilderTypes.AccountAddress.fromHex(arg).serialize(serializer);
            break;
        case 'u8':
            serializer.serializeU8((0, ensureTypes_js_1.ensureNumber)(arg));
            break;
        case 'u16':
            serializer.serializeU16((0, ensureTypes_js_1.ensureNumber)(arg));
            break;
        case 'u32':
            serializer.serializeU32((0, ensureTypes_js_1.ensureNumber)(arg));
            break;
        case 'u64':
            serializer.serializeU64((0, ensureTypes_js_1.ensureBigInt)(arg));
            break;
        case 'u128':
            serializer.serializeU128((0, ensureTypes_js_1.ensureBigInt)(arg));
            break;
        case 'u256':
            serializer.serializeU256((0, ensureTypes_js_1.ensureBigInt)(arg));
            break;
        case '0x1::string::String':
            serializer.serializeStr(arg);
            break;
        default:
            throw new Error(`type "${type}" not supported`);
    }
}
//# sourceMappingURL=createEntryPayload.js.map