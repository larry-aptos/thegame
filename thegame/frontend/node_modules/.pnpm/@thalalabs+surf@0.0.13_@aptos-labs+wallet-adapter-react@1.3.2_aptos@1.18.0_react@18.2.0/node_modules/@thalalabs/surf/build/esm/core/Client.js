import { AptosClient, TxnBuilderTypes } from 'aptos';
import { createViewPayload } from './createViewPayload.js';
import { createEntryPayload } from './createEntryPayload.js';
export function createClient(options) {
    return new Client(new AptosClient(options.nodeUrl));
}
export class Client {
    constructor(client) {
        Object.defineProperty(this, "client", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.client = client;
    }
    async view(payload, options) {
        const result = await this.client.view(payload.viewRequest, options?.ledger_version);
        return result.map((value, i) => payload.decoders[i] ? payload.decoders[i](value) : value);
    }
    async submitTransaction(payload, options) {
        const rawTxn = await this.generateRawTxn(payload, options);
        const bcsTxn = AptosClient.generateBCSTransaction(options.account, rawTxn);
        const transactionRes = await this.client.submitSignedBCSTransaction(bcsTxn);
        await this.client.waitForTransaction(transactionRes.hash, {
            timeoutSecs: 120,
            checkSuccess: true,
        });
        return transactionRes;
    }
    async simulateTransaction(payload, options) {
        const rawTxn = await this.generateRawTxn(payload, options);
        const transactionRes = (await this.client.simulateTransaction(options.account, rawTxn))[0];
        if (!transactionRes) {
            throw new Error('Failed to simulate transaction');
        }
        return transactionRes;
    }
    useABI(abi) {
        return {
            view: new Proxy({}, {
                get: (_, prop) => {
                    const functionName = prop.toString();
                    return (...args) => {
                        const payload = createViewPayload(abi, {
                            function: functionName,
                            type_arguments: args[0].type_arguments,
                            arguments: args[0].arguments,
                        });
                        return this.view(payload);
                    };
                },
            }),
            entry: new Proxy({}, {
                get: (_, prop) => {
                    const functionName = prop.toString();
                    return (...args) => {
                        const payload = createEntryPayload(abi, {
                            function: functionName,
                            type_arguments: args[0].type_arguments,
                            arguments: args[0].arguments,
                        });
                        return args[0].isSimulation
                            ? this.simulateTransaction(payload, { account: args[0].account })
                            : this.submitTransaction(payload, { account: args[0].account });
                    };
                },
            }),
            resource: new Proxy({}, {
                get: (_, prop) => {
                    let structName = prop.toString();
                    return (...args) => {
                        if (args[0].type_arguments.length !== 0) {
                            structName += `<${args[0].type_arguments.join(',')}>`;
                        }
                        return this.client.getAccountResource(args[0].account, `${abi.address}::${abi.name}::${structName}`);
                    };
                },
            }),
        };
    }
    async generateRawTxn(payload, options) {
        const { account } = options;
        const entryFunctionPayload = new TxnBuilderTypes.TransactionPayloadEntryFunction(payload.entryRequest);
        const rawTxn = await this.client.generateRawTransaction(account.address(), entryFunctionPayload);
        return rawTxn;
    }
}
//# sourceMappingURL=Client.js.map