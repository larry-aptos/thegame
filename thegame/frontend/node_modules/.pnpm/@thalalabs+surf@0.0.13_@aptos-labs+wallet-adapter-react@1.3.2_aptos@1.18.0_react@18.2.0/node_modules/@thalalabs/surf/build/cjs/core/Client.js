"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Client = exports.createClient = void 0;
const aptos_1 = require("aptos");
const createViewPayload_js_1 = require("./createViewPayload.js");
const createEntryPayload_js_1 = require("./createEntryPayload.js");
function createClient(options) {
    return new Client(new aptos_1.AptosClient(options.nodeUrl));
}
exports.createClient = createClient;
class Client {
    constructor(client) {
        Object.defineProperty(this, "client", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.client = client;
    }
    async view(payload, options) {
        const result = await this.client.view(payload.viewRequest, options?.ledger_version);
        return result.map((value, i) => payload.decoders[i] ? payload.decoders[i](value) : value);
    }
    async submitTransaction(payload, options) {
        const rawTxn = await this.generateRawTxn(payload, options);
        const bcsTxn = aptos_1.AptosClient.generateBCSTransaction(options.account, rawTxn);
        const transactionRes = await this.client.submitSignedBCSTransaction(bcsTxn);
        await this.client.waitForTransaction(transactionRes.hash, {
            timeoutSecs: 120,
            checkSuccess: true,
        });
        return transactionRes;
    }
    async simulateTransaction(payload, options) {
        const rawTxn = await this.generateRawTxn(payload, options);
        const transactionRes = (await this.client.simulateTransaction(options.account, rawTxn))[0];
        if (!transactionRes) {
            throw new Error('Failed to simulate transaction');
        }
        return transactionRes;
    }
    useABI(abi) {
        return {
            view: new Proxy({}, {
                get: (_, prop) => {
                    const functionName = prop.toString();
                    return (...args) => {
                        const payload = (0, createViewPayload_js_1.createViewPayload)(abi, {
                            function: functionName,
                            type_arguments: args[0].type_arguments,
                            arguments: args[0].arguments,
                        });
                        return this.view(payload);
                    };
                },
            }),
            entry: new Proxy({}, {
                get: (_, prop) => {
                    const functionName = prop.toString();
                    return (...args) => {
                        const payload = (0, createEntryPayload_js_1.createEntryPayload)(abi, {
                            function: functionName,
                            type_arguments: args[0].type_arguments,
                            arguments: args[0].arguments,
                        });
                        return args[0].isSimulation
                            ? this.simulateTransaction(payload, { account: args[0].account })
                            : this.submitTransaction(payload, { account: args[0].account });
                    };
                },
            }),
            resource: new Proxy({}, {
                get: (_, prop) => {
                    let structName = prop.toString();
                    return (...args) => {
                        if (args[0].type_arguments.length !== 0) {
                            structName += `<${args[0].type_arguments.join(',')}>`;
                        }
                        return this.client.getAccountResource(args[0].account, `${abi.address}::${abi.name}::${structName}`);
                    };
                },
            }),
        };
    }
    async generateRawTxn(payload, options) {
        const { account } = options;
        const entryFunctionPayload = new aptos_1.TxnBuilderTypes.TransactionPayloadEntryFunction(payload.entryRequest);
        const rawTxn = await this.client.generateRawTransaction(account.address(), entryFunctionPayload);
        return rawTxn;
    }
}
exports.Client = Client;
//# sourceMappingURL=Client.js.map