import {
  require_buffer
} from "./chunk-RD5UI6NA.js";
import {
  HexString
} from "./chunk-R3KJZ7NN.js";
import {
  __commonJS,
  __toESM
} from "./chunk-WNKWOKNR.js";

// node_modules/.pnpm/make-error@1.3.6/node_modules/make-error/index.js
var require_make_error = __commonJS({
  "node_modules/.pnpm/make-error@1.3.6/node_modules/make-error/index.js"(exports, module) {
    "use strict";
    var construct = typeof Reflect !== "undefined" ? Reflect.construct : void 0;
    var defineProperty = Object.defineProperty;
    var captureStackTrace = Error.captureStackTrace;
    if (captureStackTrace === void 0) {
      captureStackTrace = function captureStackTrace2(error) {
        var container = new Error();
        defineProperty(error, "stack", {
          configurable: true,
          get: function getStack() {
            var stack = container.stack;
            defineProperty(this, "stack", {
              configurable: true,
              value: stack,
              writable: true
            });
            return stack;
          },
          set: function setStack(stack) {
            defineProperty(error, "stack", {
              configurable: true,
              value: stack,
              writable: true
            });
          }
        });
      };
    }
    function BaseError(message) {
      if (message !== void 0) {
        defineProperty(this, "message", {
          configurable: true,
          value: message,
          writable: true
        });
      }
      var cname = this.constructor.name;
      if (cname !== void 0 && cname !== this.name) {
        defineProperty(this, "name", {
          configurable: true,
          value: cname,
          writable: true
        });
      }
      captureStackTrace(this, this.constructor);
    }
    BaseError.prototype = Object.create(Error.prototype, {
      // See: https://github.com/JsCommunity/make-error/issues/4
      constructor: {
        configurable: true,
        value: BaseError,
        writable: true
      }
    });
    var setFunctionName = function() {
      function setFunctionName2(fn, name) {
        return defineProperty(fn, "name", {
          configurable: true,
          value: name
        });
      }
      try {
        var f = function() {
        };
        setFunctionName2(f, "foo");
        if (f.name === "foo") {
          return setFunctionName2;
        }
      } catch (_) {
      }
    }();
    function makeError(constructor, super_) {
      if (super_ == null || super_ === Error) {
        super_ = BaseError;
      } else if (typeof super_ !== "function") {
        throw new TypeError("super_ should be a function");
      }
      var name;
      if (typeof constructor === "string") {
        name = constructor;
        constructor = construct !== void 0 ? function() {
          return construct(super_, arguments, this.constructor);
        } : function() {
          super_.apply(this, arguments);
        };
        if (setFunctionName !== void 0) {
          setFunctionName(constructor, name);
          name = void 0;
        }
      } else if (typeof constructor !== "function") {
        throw new TypeError("constructor should be either a string or a function");
      }
      constructor.super_ = constructor["super"] = super_;
      var properties = {
        constructor: {
          configurable: true,
          value: constructor,
          writable: true
        }
      };
      if (name !== void 0) {
        properties.name = {
          configurable: true,
          value: name,
          writable: true
        };
      }
      constructor.prototype = Object.create(super_.prototype, properties);
      return constructor;
    }
    exports = module.exports = makeError;
    exports.BaseError = BaseError;
  }
});

// node_modules/.pnpm/json-rpc-protocol@0.13.2/node_modules/json-rpc-protocol/dist/errors.js
var require_errors = __commonJS({
  "node_modules/.pnpm/json-rpc-protocol@0.13.2/node_modules/json-rpc-protocol/dist/errors.js"(exports) {
    "use strict";
    var __extends = exports && exports.__extends || function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (b2.hasOwnProperty(p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.InvalidParameters = exports.MethodNotFound = exports.InvalidRequest = exports.InvalidJson = exports.JsonRpcError = void 0;
    var make_error_1 = require_make_error();
    var JsonRpcError2 = (
      /** @class */
      function(_super) {
        __extends(JsonRpcError3, _super);
        function JsonRpcError3(message, code, data) {
          if (message === void 0) {
            message = "unknown error from the peer";
          }
          if (code === void 0) {
            code = -32e3;
          }
          var _this = _super.call(this, message) || this;
          _this.code = code;
          _this.data = data;
          return _this;
        }
        JsonRpcError3.prototype.toJsonRpcError = function() {
          return {
            code: this.code,
            data: this.data,
            message: this.message
          };
        };
        return JsonRpcError3;
      }(make_error_1.BaseError)
    );
    exports.JsonRpcError = JsonRpcError2;
    var InvalidJson = (
      /** @class */
      function(_super) {
        __extends(InvalidJson2, _super);
        function InvalidJson2() {
          return _super.call(this, "invalid JSON", -32700) || this;
        }
        return InvalidJson2;
      }(JsonRpcError2)
    );
    exports.InvalidJson = InvalidJson;
    var InvalidRequest = (
      /** @class */
      function(_super) {
        __extends(InvalidRequest2, _super);
        function InvalidRequest2(message) {
          if (message === void 0) {
            message = "invalid JSON-RPC request";
          }
          return _super.call(this, message, -32600) || this;
        }
        return InvalidRequest2;
      }(JsonRpcError2)
    );
    exports.InvalidRequest = InvalidRequest;
    var MethodNotFound = (
      /** @class */
      function(_super) {
        __extends(MethodNotFound2, _super);
        function MethodNotFound2(method) {
          var _this = this;
          var message = method ? "method not found: " + method : "method not found";
          _this = _super.call(this, message, -32601, method) || this;
          return _this;
        }
        return MethodNotFound2;
      }(JsonRpcError2)
    );
    exports.MethodNotFound = MethodNotFound;
    var InvalidParameters = (
      /** @class */
      function(_super) {
        __extends(InvalidParameters2, _super);
        function InvalidParameters2(data) {
          return _super.call(this, "invalid parameter(s)", -32602, data) || this;
        }
        return InvalidParameters2;
      }(JsonRpcError2)
    );
    exports.InvalidParameters = InvalidParameters;
  }
});

// node_modules/.pnpm/json-rpc-protocol@0.13.2/node_modules/json-rpc-protocol/dist/format.js
var require_format = __commonJS({
  "node_modules/.pnpm/json-rpc-protocol@0.13.2/node_modules/json-rpc-protocol/dist/format.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.response = exports.request = exports.notification = exports.error = void 0;
    var errors_1 = require_errors();
    var toJson = JSON.stringify;
    exports.error = function(id, err) {
      if (err == null || typeof err.toJsonRpcError !== "function") {
        err = new errors_1.JsonRpcError();
      }
      var errorPayload = err.toJsonRpcError();
      return toJson({
        error: errorPayload,
        id,
        jsonrpc: "2.0"
      });
    };
    exports.notification = function(method, params) {
      return toJson({
        jsonrpc: "2.0",
        method,
        params
      });
    };
    exports.request = function(id, method, params) {
      return toJson({
        id,
        jsonrpc: "2.0",
        method,
        params
      });
    };
    exports.response = function(id, result) {
      return toJson({
        id,
        jsonrpc: "2.0",
        result
      });
    };
  }
});

// node_modules/.pnpm/json-rpc-protocol@0.13.2/node_modules/json-rpc-protocol/dist/json-rpc.type.js
var require_json_rpc_type = __commonJS({
  "node_modules/.pnpm/json-rpc-protocol@0.13.2/node_modules/json-rpc-protocol/dist/json-rpc.type.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/.pnpm/json-rpc-protocol@0.13.2/node_modules/json-rpc-protocol/dist/types.js
var require_types = __commonJS({
  "node_modules/.pnpm/json-rpc-protocol@0.13.2/node_modules/json-rpc-protocol/dist/types.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isObject = exports.isString = exports.isInteger = exports.isNumber = void 0;
    var negativeInf = Number.NEGATIVE_INFINITY;
    var positiveInf = Number.POSITIVE_INFINITY;
    exports.isNumber = function(value) {
      var type = typeof value;
      return type === "number" && value > negativeInf && value < positiveInf;
    };
    exports.isInteger = function(value) {
      return exports.isNumber(value) && value % 1 === 0;
    };
    exports.isString = function(value) {
      return typeof value === "string";
    };
    exports.isObject = function(value) {
      var type = typeof value;
      return value !== null && (type === "object" || type === "function");
    };
  }
});

// node_modules/.pnpm/json-rpc-protocol@0.13.2/node_modules/json-rpc-protocol/dist/parse.js
var require_parse = __commonJS({
  "node_modules/.pnpm/json-rpc-protocol@0.13.2/node_modules/json-rpc-protocol/dist/parse.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.parse = exports.isResponsePayload = exports.isErrorPayload = exports.isRequestPayload = exports.isNotificationPayload = void 0;
    var types_1 = require_types();
    var errors_1 = require_errors();
    var defineProperty = Object.defineProperty;
    var setMessageType = function(message, type) {
      return defineProperty(message, "type", {
        configurable: true,
        value: type,
        writable: true
      });
    };
    var getType = function(value) {
      return value === null ? "null" : typeof value;
    };
    var checkError = function(error, version2) {
      if (version2 === "1.0") {
        if (error == null) {
          throw new errors_1.InvalidRequest("invalid error " + getType(error));
        }
      } else if (error == null || !types_1.isInteger(error.code) || !types_1.isString(error.message)) {
        throw new errors_1.InvalidRequest("invalid error: " + getType(error) + " instead of {code, message}");
      }
    };
    var checkId = function(id) {
      if (!types_1.isNumber(id) && !types_1.isString(id)) {
        throw new errors_1.InvalidRequest("invalid identifier: " + getType(id) + " instead of number or string");
      }
    };
    var checkParams = function(params, version2) {
      if (version2 === "2.0") {
        if (params !== void 0 && !Array.isArray(params) && !types_1.isObject(params)) {
          throw new errors_1.InvalidRequest("invalid params: " + getType(params) + " instead of undefined, array or object");
        }
      } else {
        if (!Array.isArray(params)) {
          throw new errors_1.InvalidRequest("invalid params: " + getType(params) + " instead of array");
        }
      }
    };
    var detectJsonRpcVersion = function(_a) {
      var jsonrpc = _a.jsonrpc;
      if (jsonrpc === void 0) {
        return "1.0";
      }
      if (jsonrpc === "2.0") {
        return "2.0";
      }
      throw new errors_1.InvalidRequest("invalid version: " + getType(jsonrpc) + " instead of undefined or '2.0'");
    };
    var isNotificationId = function(id, version2) {
      return id === (version2 === "2.0" ? void 0 : null);
    };
    var isErrorResponse = function(_a, version2) {
      var error = _a.error;
      return error !== (version2 === "2.0" ? void 0 : null);
    };
    exports.isNotificationPayload = function(message, version2) {
      if (types_1.isString(message.method)) {
        var id = message.id;
        if (isNotificationId(id, version2)) {
          checkParams(message.params, version2);
          return true;
        }
      }
      return false;
    };
    exports.isRequestPayload = function(message, version2) {
      if (types_1.isString(message.method)) {
        var id = message.id;
        if (!isNotificationId(id, version2)) {
          checkId(id);
          checkParams(message.params, version2);
          return true;
        }
      }
      return false;
    };
    exports.isErrorPayload = function(message, version2) {
      if (!types_1.isString(message.method)) {
        if (isErrorResponse(message, version2)) {
          var id = message.id;
          if (id !== null) {
            checkId(id);
          }
          checkError(message.error, version2);
          return true;
        }
      }
      return false;
    };
    exports.isResponsePayload = function(message, version2) {
      if (!types_1.isString(message.method)) {
        if (!isErrorResponse(message, version2)) {
          checkId(message.id);
          return true;
        }
      }
      return false;
    };
    function parse3(message) {
      if (types_1.isString(message)) {
        try {
          message = JSON.parse(message);
        } catch (error) {
          if (error instanceof SyntaxError) {
            throw new errors_1.InvalidJson();
          }
          throw error;
        }
      }
      if (Array.isArray(message)) {
        return message.map(parse3);
      }
      var version2 = detectJsonRpcVersion(message);
      if (exports.isNotificationPayload(message, version2)) {
        setMessageType(message, "notification");
      } else if (exports.isRequestPayload(message, version2)) {
        setMessageType(message, "request");
      } else if (exports.isErrorPayload(message, version2)) {
        setMessageType(message, "error");
      } else if (exports.isResponsePayload(message, version2)) {
        setMessageType(message, "response");
      } else {
        throw new errors_1.InvalidJson();
      }
      return message;
    }
    exports.parse = parse3;
    exports.default = parse3;
    parse3.result = function result(message) {
      var parsed = parse3(message);
      if (!Array.isArray(parsed)) {
        if (parsed.type === "error") {
          throw parsed.error;
        }
        if (parsed.type === "response") {
          return parsed.result;
        }
      }
      throw new TypeError("message should be response or error JSON-RPC message");
    };
  }
});

// node_modules/.pnpm/json-rpc-protocol@0.13.2/node_modules/json-rpc-protocol/dist/index.js
var require_dist = __commonJS({
  "node_modules/.pnpm/json-rpc-protocol@0.13.2/node_modules/json-rpc-protocol/dist/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !exports2.hasOwnProperty(p))
          __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.format = void 0;
    var format3 = __importStar(require_format());
    exports.format = format3;
    __exportStar(require_json_rpc_type(), exports);
    __exportStar(require_errors(), exports);
    var parse_1 = require_parse();
    Object.defineProperty(exports, "parse", { enumerable: true, get: function() {
      return parse_1.parse;
    } });
  }
});

// node_modules/.pnpm/msafe-wallet@2.1.5/node_modules/msafe-wallet/dist/index.mjs
var import_json_rpc_protocol = __toESM(require_dist(), 1);
var import_buffer = __toESM(require_buffer(), 1);
var import_json_rpc_protocol2 = __toESM(require_dist(), 1);
function concat(list) {
  const total = list.reduce((size, a) => size + a.length, 0);
  const arr = new Uint8Array(total);
  let offset = 0;
  list.forEach((a) => {
    arr.set(a, offset);
    offset += a.length;
  });
  return arr;
}
var Decoder = class {
  constructor(data, byteOffset = data.byteOffset) {
    this.data = data;
    this.byteOffset = byteOffset;
  }
  read(byteLength) {
    const result = new Uint8Array(this.data.buffer, this.byteOffset, byteLength);
    this.byteOffset += byteLength;
    return result;
  }
  decodeBigInt() {
    return BigInt(this.decodeString());
  }
  decodeNumber() {
    return Number(this.decodeString());
  }
  decodeUint8Array() {
    const length = new Uint32Array(this.read(4).slice(0).buffer)[0];
    return this.read(length);
  }
  decodeBoolean() {
    return Boolean(this.read(1)[0]);
  }
  decodeString() {
    const de = this.decodeUint8Array();
    return import_buffer.Buffer.from(de).toString();
  }
  decodeArray() {
    const length = this.decode();
    return Array(length).fill(0).map(() => this.decode());
  }
  decodeObject() {
    const length = this.decode();
    const entries = Array(length).fill(0).map(() => [this.decode(), this.decode()]);
    return Object.fromEntries(entries);
  }
  decode() {
    const type = this.read(1)[0];
    switch (type) {
      case 2:
        return this.decodeBigInt();
      case 1:
        return this.decodeNumber();
      case 0:
        return this.decodeBoolean();
      case 3:
        return this.decodeString();
      case 4:
        return this.decodeUint8Array();
      case 6:
        return this.decodeArray();
      case 5:
        return this.decodeObject();
      case 7:
        return void 0;
      case 8:
        return null;
    }
    throw `unkonw type: ${type}`;
  }
};
function encodeUint8Array(data) {
  const en = new Uint8Array(data.length + 5);
  en[0] = 4;
  import_buffer.Buffer.from(en.buffer, 1, 4).writeUInt32LE(data.length);
  en.set(data, 5);
  return en;
}
function encodeUndefined() {
  return Uint8Array.from([
    7
    /* Undefined */
  ]);
}
function encodeNull() {
  return Uint8Array.from([
    8
    /* Null */
  ]);
}
function encodeBigInt(data) {
  const en = encodeString(data.toString());
  en[0] = 2;
  return en;
}
function encodeNumber(data) {
  const en = encodeString(data.toString());
  en[0] = 1;
  return en;
}
function encodeBoolean(data) {
  return new Uint8Array([0, Number(data)]);
}
function encodeString(data) {
  const buf = new ArrayBuffer(data.length);
  import_buffer.Buffer.from(buf).write(data);
  const en = encodeUint8Array(new Uint8Array(buf));
  en[0] = 3;
  return en;
}
function encodeObject(data) {
  const entries = Object.entries(data);
  const ens = entries.map(([key, value]) => {
    const keyBuf = encode(key);
    const valueBuf = encode(value);
    return concat([keyBuf, valueBuf]);
  });
  return concat([Uint8Array.from([
    5
    /* Object */
  ]), encode(entries.length), ...ens]);
}
function encodeArray(data) {
  const ens = data.map((elem) => encode(elem));
  return concat([Uint8Array.from([
    6
    /* Array */
  ]), encode(ens.length), ...ens]);
}
function encode(data) {
  if (data instanceof Uint8Array) {
    return encodeUint8Array(data);
  }
  if (data instanceof Array) {
    return encodeArray(data);
  }
  if (data instanceof Object) {
    return encodeObject(data);
  }
  if (data === null) {
    return encodeNull();
  }
  switch (typeof data) {
    case "string":
      return encodeString(data);
    case "number":
      return encodeNumber(data);
    case "bigint":
      return encodeBigInt(data);
    case "boolean":
      return encodeBoolean(data);
    case "undefined":
      return encodeUndefined();
  }
  throw `unsuport type: ${data}`;
}
function decode(data) {
  const decoder = new Decoder(data);
  return decoder.decode();
}
function encodeToStr(data) {
  return import_buffer.Buffer.from(encode(data).buffer).toString("hex");
}
function decodeFromStr(data) {
  const buffer = new ArrayBuffer(data.length / 2);
  import_buffer.Buffer.from(buffer).write(data, "hex");
  return decode(new Uint8Array(buffer));
}
var WalletEvent = ((WalletEvent2) => {
  WalletEvent2["ChangeAccount"] = "ChangeAccountEvent";
  WalletEvent2["ChangeNetwork"] = "ChangeNetworkEvent";
  return WalletEvent2;
})(WalletEvent || {});
var WalletRPC = ((WalletRPC2) => {
  WalletRPC2["connect"] = "connect";
  WalletRPC2["disconnect"] = "disconnect";
  WalletRPC2["isConnected"] = "isConnected";
  WalletRPC2["network"] = "network";
  WalletRPC2["account"] = "account";
  WalletRPC2["chainId"] = "chainId";
  WalletRPC2["signAndSubmit"] = "signAndSubmit";
  WalletRPC2["signTransaction"] = "signTransaction";
  WalletRPC2["signMessage"] = "signMessage";
  return WalletRPC2;
})(WalletRPC || {});
function cmp(a, b) {
  const parse3 = (version2) => version2.split(".").map(Number);
  const [majorA, minorA, batchA] = parse3(a);
  const [majorB, minorB, batchB] = parse3(b);
  if (majorA > majorB)
    return 1;
  if (majorA < majorB)
    return -1;
  if (minorA > minorB)
    return 1;
  if (minorA < minorB)
    return -1;
  if (batchA > batchB)
    return 1;
  if (batchA < batchB)
    return -1;
  return 0;
}
function isSessionIDVersion(version2) {
  return version2 !== void 0 && cmp(
    version2,
    "2.1.4"
    /* SESSION_ID */
  ) >= 0;
}
function isAllowList(version2) {
  return version2 !== void 0 && cmp(
    version2,
    "2.0.5"
    /* ALLOWLIST */
  ) >= 0;
}
function isVersionedHandshakeVersion(version2) {
  return version2 !== void 0;
}
var version = "2.1.4";
var _HandshakeMessage = class {
  constructor(handshakeType, version2, sessionID) {
    this.handshakeType = handshakeType;
    if (version2 !== void 0)
      this.version = version2;
    if (sessionID !== void 0)
      this.sessionID = sessionID;
  }
  toString(messageVersion) {
    if (isSessionIDVersion(messageVersion)) {
      if (this.sessionID === void 0)
        throw Error("sessionID is undefined");
      return `${this.handshakeType}:${this.version}:${this.sessionID}`;
    }
    if (isVersionedHandshakeVersion(messageVersion))
      return `${this.handshakeType}:${this.version}`;
    return this.handshakeType;
  }
  isHandshakeMessage(handshakeType) {
    if (this.handshakeType !== handshakeType)
      return false;
    if (isSessionIDVersion(this.version) && this.sessionID === void 0)
      return false;
    return true;
  }
  static fromString(message) {
    const [handshakeType, version2, sessionID] = message.split(":");
    return new _HandshakeMessage(handshakeType, version2, Number(sessionID));
  }
};
var HandshakeMessage = _HandshakeMessage;
HandshakeMessage.HANDSHAKE_REQ = "HANDSHAKE_REQ";
HandshakeMessage.HANDSHAKE_ACK = "HANDSHAKE_ACK";
HandshakeMessage.HANDSHAKE_PORT_ACK = "HANDSHAKE_PORT_REQ";
var _Connector = class {
  constructor(port, peerVersion, sessionID) {
    this.port = port;
    this.peerVersion = peerVersion;
    this.sessionID = sessionID;
    this.connected = true;
    this.port.onmessage = (ev) => {
      this.onMessage && this.onMessage(ev.data);
    };
    this.port.onmessageerror = () => {
      this.close();
    };
  }
  send(data) {
    this.port.postMessage(data);
  }
  on(type, handle) {
    switch (type) {
      case "close":
        this.onClose = handle;
        break;
      case "message":
        this.onMessage = handle;
        break;
      default:
        throw Error("invlaid type");
    }
  }
  get version() {
    return {
      self: _Connector.version,
      peer: this.peerVersion
    };
  }
  close() {
    if (this.connected) {
      this.port.close();
      this.connected = false;
      this.onClose && this.onClose();
    }
  }
  static newSessionID() {
    return _Connector.sessionID++;
  }
  static async connect(targetWindow, origins) {
    return new Promise((resolve, rejected) => {
      const sessionID = _Connector.newSessionID();
      let cleaner = () => {
      };
      let timer = setTimeout(() => {
        cleaner();
        rejected(`connect timeout: ${sessionID}`);
      }, 1e3);
      const handle = (ev) => {
        const port = ev.ports[0];
        if (!origins.includes(ev.origin))
          return;
        if (typeof ev.data !== "string")
          return;
        const handshakeMessage2 = HandshakeMessage.fromString(ev.data);
        if (!handshakeMessage2.isHandshakeMessage(HandshakeMessage.HANDSHAKE_PORT_ACK))
          return;
        if (handshakeMessage2.sessionID !== sessionID)
          return;
        cleaner();
        resolve(new _Connector(port, handshakeMessage2.version, sessionID));
      };
      cleaner = () => {
        clearTimeout(timer);
        window.removeEventListener("message", handle);
      };
      window.addEventListener("message", handle);
      const handshakeMessage = new HandshakeMessage(HandshakeMessage.HANDSHAKE_REQ, _Connector.version, sessionID);
      targetWindow.postMessage(handshakeMessage.toString(handshakeMessage.version), "*");
    });
  }
  static accepts(origin, handler) {
    origin = new URL(origin).origin;
    const handle = (ev) => {
      if (ev.origin !== origin)
        return;
      if (typeof ev.data !== "string")
        return;
      const handshakeMessage = HandshakeMessage.fromString(ev.data);
      if (!handshakeMessage.isHandshakeMessage(HandshakeMessage.HANDSHAKE_REQ))
        return;
      const peerVersion = handshakeMessage.version;
      const thisVersion = _Connector.version;
      if (isSessionIDVersion(peerVersion)) {
        const channelPair = new MessageChannel();
        const replyMessage = new HandshakeMessage(HandshakeMessage.HANDSHAKE_PORT_ACK, thisVersion, handshakeMessage.sessionID);
        ev.source.postMessage(replyMessage.toString(peerVersion), ev.origin, [channelPair.port2]);
        handler(new _Connector(channelPair.port1, peerVersion, handshakeMessage.sessionID));
      } else if (isAllowList(peerVersion)) {
        const channelPair = new MessageChannel();
        const replyMessage = new HandshakeMessage(HandshakeMessage.HANDSHAKE_PORT_ACK, thisVersion);
        ev.source.postMessage(replyMessage.toString(peerVersion), ev.origin, [channelPair.port2]);
        handler(new _Connector(channelPair.port1, peerVersion, void 0));
      } else {
        const port = ev.ports[0];
        const replyMessage = new HandshakeMessage(HandshakeMessage.HANDSHAKE_ACK, thisVersion);
        port.postMessage(replyMessage.toString(peerVersion));
        handler(new _Connector(ev.ports[0], peerVersion, void 0));
      }
    };
    window.addEventListener("message", handle);
    return () => window.removeEventListener("message", handle);
  }
  static async accept(origin) {
    return new Promise((resolve) => {
      const cleaner = this.accepts(origin, (connector) => {
        resolve(connector);
        cleaner();
      });
    });
  }
};
var Connector = _Connector;
Connector.version = version;
Connector.sessionID = 0;
var JsonRPCClient = class {
  constructor(connector, notifiers) {
    this.connector = connector;
    this.notifiers = notifiers;
    this.id = 0;
    this.executors = {};
    this.connector.on("message", (data) => this.onMessage(data));
    this.connector.on("close", () => this.onClose());
  }
  onMessage(data) {
    const mesg = (0, import_json_rpc_protocol2.parse)(data);
    switch (mesg.type) {
      case "notification":
        return this.onNotify(mesg.method, mesg.params.map(decodeFromStr));
      case "response":
        const { resolve } = this.executors[Number(mesg.id)];
        delete this.executors[Number(mesg.id)];
        return resolve(decodeFromStr(mesg.result));
      case "error":
        const { reject } = this.executors[Number(mesg.id)];
        delete this.executors[Number(mesg.id)];
        return reject(mesg.error.message);
    }
  }
  async request(method, params = []) {
    return new Promise((resolve, reject) => {
      const reqId = this.id++;
      this.executors[reqId] = { resolve, reject };
      const req = import_json_rpc_protocol2.format.request(reqId, method, params.map(encodeToStr));
      this.connector.send(req);
    });
  }
  get version() {
    return this.connector.version;
  }
  onNotify(type, data) {
    this.notifiers[type](...data);
  }
  onClose() {
  }
};
var MSafeOrigins = {
  mainnet: "https://app.m-safe.io",
  testnet: "https://testnet.m-safe.io",
  partner: "https://partner.m-safe.io"
};
var DefaultMSafeEndpoints = Object.values(MSafeOrigins);
var MSafeWallet = class {
  constructor(connector) {
    this.events = {};
    const onEvent = (type, ...params) => {
      const cbk = this.events[type];
      cbk && cbk(params[0]);
    };
    const entries = [
      "ChangeAccountEvent",
      "ChangeNetworkEvent"
      /* ChangeNetwork */
    ].map((event) => [event, (...params) => onEvent(event, ...params)]);
    const notifiers = Object.fromEntries(entries);
    this.client = new JsonRPCClient(connector, notifiers);
  }
  async connect() {
    return this.client.request(
      "connect"
      /* connect */
    );
  }
  async isConnected() {
    return this.client.request(
      "isConnected"
      /* isConnected */
    );
  }
  async disconnect() {
    return this.client.request(
      "disconnect"
      /* disconnect */
    );
  }
  onChangeAccount(cbk) {
    this.events[
      "ChangeAccountEvent"
      /* ChangeAccount */
    ] = cbk;
  }
  onChangeNetwork(cbk) {
    this.events[
      "ChangeNetworkEvent"
      /* ChangeNetwork */
    ] = cbk;
  }
  async network() {
    return this.client.request(
      "network"
      /* network */
    );
  }
  async account() {
    return this.client.request(
      "account"
      /* account */
    );
  }
  async chainId() {
    return this.client.request(
      "chainId"
      /* chainId */
    );
  }
  async signAndSubmit(payload, option) {
    return this.client.request("signAndSubmit", [payload, option]);
  }
  async signTransaction(payload, option) {
    return this.client.request("signTransaction", [payload, option]);
  }
  async signMessage(message) {
    return this.client.request("signMessage", [message]);
  }
  get version() {
    return this.client.version;
  }
  static inMSafeWallet() {
    return typeof window !== "undefined" && typeof document !== "undefined" && typeof parent !== "undefined" && typeof parent.window !== "undefined" && parent.window !== window;
  }
  static inMsafeWallet() {
    return MSafeWallet.inMSafeWallet();
  }
  static getAppUrl(msafe = "mainnet", dappUrl = `${window.location.href}`) {
    const msafeOrigin = MSafeWallet.getOrigin(msafe);
    return `${msafeOrigin}/aptos/v2/store/0?url=${encodeURIComponent(dappUrl)}`;
  }
  static getOrigin(msafeNetwork = "mainnet") {
    const endpoint = MSafeOrigins[msafeNetwork.toLowerCase()] || msafeNetwork;
    return new URL(endpoint).origin;
  }
  static async new(allowlist = DefaultMSafeEndpoints) {
    const msafeOrigin = allowlist instanceof Array ? allowlist.map((m) => MSafeWallet.getOrigin(m)) : [MSafeWallet.getOrigin(allowlist)];
    const connector = await Connector.connect(window.parent, msafeOrigin);
    return new MSafeWallet(connector);
  }
};

// node_modules/.pnpm/msafe-plugin-wallet-adapter@0.1.0/node_modules/msafe-plugin-wallet-adapter/dist/index.mjs
var toNetworkName = (network) => network;
function toPluginProvider(msafe) {
  return {
    connect: () => {
      return msafe.connect();
    },
    account: () => {
      return msafe.account();
    },
    disconnect: () => {
      return msafe.disconnect();
    },
    signAndSubmitTransaction: async (transaction, options) => {
      const result = await msafe.signAndSubmit(transaction, options);
      return { hash: HexString.fromUint8Array(result).hex() };
    },
    signMessage: (message) => {
      throw "unpported";
    },
    network: () => {
      return msafe.network().then((network) => toNetworkName(network));
    },
    onAccountChange: async (listener) => {
      return msafe.onChangeAccount((newAddress) => listener(newAddress));
    },
    onNetworkChange: async (listener) => {
      const listenerProxy = async (network) => {
        const chainId = await msafe.chainId();
        const networkName = {
          name: toNetworkName(network),
          chainId: chainId.toString()
        };
        listener({ networkName });
      };
      return msafe.onChangeNetwork((network) => listenerProxy(network));
    }
  };
}
var LOGO_PNG_BASE64 = "iVBORw0KGgoAAAANSUhEUgAAAMAAAADACAYAAABS3GwHAAAAAXNSR0IArs4c6QAAAOZlWElmTU0AKgAAAAgABgESAAMAAAABAAEAAAEaAAUAAAABAAAAVgEbAAUAAAABAAAAXgExAAIAAAAhAAAAZgEyAAIAAAAUAAAAiIdpAAQAAAABAAAAnAAAAAAAAAEsAAAAAQAAASwAAAABQWRvYmUgUGhvdG9zaG9wIDIzLjMgKE1hY2ludG9zaCkAADIwMjI6MDk6MjkgMjM6MjM6MDIAAASQBAACAAAAFAAAANKgAQADAAAAAQABAACgAgAEAAAAAQAAAMCgAwAEAAAAAQAAAMAAAAAAMjAyMjowOToyNyAyMTo1Mjo1OACFdF25AAAACXBIWXMAAC4jAAAuIwF4pT92AAAL4mlUWHRYTUw6Y29tLmFkb2JlLnhtcAAAAAAAPHg6eG1wbWV0YSB4bWxuczp4PSJhZG9iZTpuczptZXRhLyIgeDp4bXB0az0iWE1QIENvcmUgNi4wLjAiPgogICA8cmRmOlJERiB4bWxuczpyZGY9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkvMDIvMjItcmRmLXN5bnRheC1ucyMiPgogICAgICA8cmRmOkRlc2NyaXB0aW9uIHJkZjphYm91dD0iIgogICAgICAgICAgICB4bWxuczpkYz0iaHR0cDovL3B1cmwub3JnL2RjL2VsZW1lbnRzLzEuMS8iCiAgICAgICAgICAgIHhtbG5zOnhtcD0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wLyIKICAgICAgICAgICAgeG1sbnM6eG1wTU09Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9tbS8iCiAgICAgICAgICAgIHhtbG5zOnN0RXZ0PSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvc1R5cGUvUmVzb3VyY2VFdmVudCMiCiAgICAgICAgICAgIHhtbG5zOnRpZmY9Imh0dHA6Ly9ucy5hZG9iZS5jb20vdGlmZi8xLjAvIgogICAgICAgICAgICB4bWxuczpwaG90b3Nob3A9Imh0dHA6Ly9ucy5hZG9iZS5jb20vcGhvdG9zaG9wLzEuMC8iPgogICAgICAgICA8ZGM6Zm9ybWF0PmltYWdlL3BuZzwvZGM6Zm9ybWF0PgogICAgICAgICA8eG1wOk1vZGlmeURhdGU+MjAyMi0wOS0yOVQyMzoyMzowMi0wNzowMDwveG1wOk1vZGlmeURhdGU+CiAgICAgICAgIDx4bXA6Q3JlYXRvclRvb2w+QWRvYmUgUGhvdG9zaG9wIDIzLjMgKE1hY2ludG9zaCk8L3htcDpDcmVhdG9yVG9vbD4KICAgICAgICAgPHhtcDpDcmVhdGVEYXRlPjIwMjItMDktMjdUMjE6NTI6NTgtMDc6MDA8L3htcDpDcmVhdGVEYXRlPgogICAgICAgICA8eG1wOk1ldGFkYXRhRGF0ZT4yMDIyLTA5LTI5VDIzOjIzOjAyLTA3OjAwPC94bXA6TWV0YWRhdGFEYXRlPgogICAgICAgICA8eG1wTU06SGlzdG9yeT4KICAgICAgICAgICAgPHJkZjpTZXE+CiAgICAgICAgICAgICAgIDxyZGY6bGkgcmRmOnBhcnNlVHlwZT0iUmVzb3VyY2UiPgogICAgICAgICAgICAgICAgICA8c3RFdnQ6c29mdHdhcmVBZ2VudD5BZG9iZSBQaG90b3Nob3AgMjMuMyAoTWFjaW50b3NoKTwvc3RFdnQ6c29mdHdhcmVBZ2VudD4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OndoZW4+MjAyMi0wOS0yN1QyMTo1Mjo1OC0wNzowMDwvc3RFdnQ6d2hlbj4KICAgICAgICAgICAgICAgICAgPHN0RXZ0Omluc3RhbmNlSUQ+eG1wLmlpZDpkNDllNWJkOC0zNDk2LTQ0M2QtYWFiMS1iYWRhNWZhNDM2ZDY8L3N0RXZ0Omluc3RhbmNlSUQ+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDphY3Rpb24+Y3JlYXRlZDwvc3RFdnQ6YWN0aW9uPgogICAgICAgICAgICAgICA8L3JkZjpsaT4KICAgICAgICAgICAgICAgPHJkZjpsaSByZGY6cGFyc2VUeXBlPSJSZXNvdXJjZSI+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDphY3Rpb24+Y29udmVydGVkPC9zdEV2dDphY3Rpb24+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDpwYXJhbWV0ZXJzPmZyb20gYXBwbGljYXRpb24vdm5kLmFkb2JlLnBob3Rvc2hvcCB0byBpbWFnZS9wbmc8L3N0RXZ0OnBhcmFtZXRlcnM+CiAgICAgICAgICAgICAgIDwvcmRmOmxpPgogICAgICAgICAgICAgICA8cmRmOmxpIHJkZjpwYXJzZVR5cGU9IlJlc291cmNlIj4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OnNvZnR3YXJlQWdlbnQ+QWRvYmUgUGhvdG9zaG9wIDIzLjMgKE1hY2ludG9zaCk8L3N0RXZ0OnNvZnR3YXJlQWdlbnQ+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDpjaGFuZ2VkPi88L3N0RXZ0OmNoYW5nZWQ+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDp3aGVuPjIwMjItMDktMjhUMTQ6NTE6MTEtMDc6MDA8L3N0RXZ0OndoZW4+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDppbnN0YW5jZUlEPnhtcC5paWQ6MjQ4YmQ1NTAtMmVjNy00Y2RkLTk5YzktODM5ZjVjNzE4MWNiPC9zdEV2dDppbnN0YW5jZUlEPgogICAgICAgICAgICAgICAgICA8c3RFdnQ6YWN0aW9uPnNhdmVkPC9zdEV2dDphY3Rpb24+CiAgICAgICAgICAgICAgIDwvcmRmOmxpPgogICAgICAgICAgICAgICA8cmRmOmxpIHJkZjpwYXJzZVR5cGU9IlJlc291cmNlIj4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OnNvZnR3YXJlQWdlbnQ+QWRvYmUgUGhvdG9zaG9wIDIzLjMgKE1hY2ludG9zaCk8L3N0RXZ0OnNvZnR3YXJlQWdlbnQ+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDpjaGFuZ2VkPi88L3N0RXZ0OmNoYW5nZWQ+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDp3aGVuPjIwMjItMDktMjlUMjM6MjM6MDItMDc6MDA8L3N0RXZ0OndoZW4+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDppbnN0YW5jZUlEPnhtcC5paWQ6YzJmMzIxODAtMmJiOC00OGY0LTk5MTYtMjM1YWM3OWY5MjE4PC9zdEV2dDppbnN0YW5jZUlEPgogICAgICAgICAgICAgICAgICA8c3RFdnQ6YWN0aW9uPnNhdmVkPC9zdEV2dDphY3Rpb24+CiAgICAgICAgICAgICAgIDwvcmRmOmxpPgogICAgICAgICAgICA8L3JkZjpTZXE+CiAgICAgICAgIDwveG1wTU06SGlzdG9yeT4KICAgICAgICAgPHhtcE1NOk9yaWdpbmFsRG9jdW1lbnRJRD54bXAuZGlkOmQ0OWU1YmQ4LTM0OTYtNDQzZC1hYWIxLWJhZGE1ZmE0MzZkNjwveG1wTU06T3JpZ2luYWxEb2N1bWVudElEPgogICAgICAgICA8eG1wTU06RG9jdW1lbnRJRD5hZG9iZTpkb2NpZDpwaG90b3Nob3A6ODk3OWY0ODAtYzM2Zi03YzQ5LWE5MDMtM2YwNzJiMmUzZDg1PC94bXBNTTpEb2N1bWVudElEPgogICAgICAgICA8eG1wTU06SW5zdGFuY2VJRD54bXAuaWlkOmMyZjMyMTgwLTJiYjgtNDhmNC05OTE2LTIzNWFjNzlmOTIxODwveG1wTU06SW5zdGFuY2VJRD4KICAgICAgICAgPHRpZmY6T3JpZW50YXRpb24+MTwvdGlmZjpPcmllbnRhdGlvbj4KICAgICAgICAgPHRpZmY6WFJlc29sdXRpb24+MzAwPC90aWZmOlhSZXNvbHV0aW9uPgogICAgICAgICA8dGlmZjpZUmVzb2x1dGlvbj4zMDA8L3RpZmY6WVJlc29sdXRpb24+CiAgICAgICAgIDxwaG90b3Nob3A6Q29sb3JNb2RlPjM8L3Bob3Rvc2hvcDpDb2xvck1vZGU+CiAgICAgIDwvcmRmOkRlc2NyaXB0aW9uPgogICA8L3JkZjpSREY+CjwveDp4bXBtZXRhPgole12SAAAqcElEQVR4Ae19C5hdVXn2XmufMzNJBQ2XAhGFZAKhBqgPqbZqbUdsa0vrpX8Nlf59FLlEIZOEkAuXcJkQQyAkJJlJIvJUn6r9+ytp/1YLqA/9f6dP+/xqJbZaI2JmEkAFFZDaBDIz5+y9+r5rrzUzSeZyzt7rzCX5dp6cOZe9117r3d/3re+6VhTJIQgIAoKAICAICAKCgCAgCAgCgoAgIAgIAoKAICAICAKCgCAgCAgCgoAgIAgIAoKAICAICAKCgCAgCAgCgoAgIAgIAoKAICAICAKCgCAgCAgCgoAgIAgIAoKAICAICAKCgCAgCAgCgoAgIAgIAoKAICAICAKCgCAgCAgCgoAgIAgIAoKAICAICAKCgCAgCAgCgoAgIAgIAoKAICAICAKCgCAgCAgCgoAgIAgIAoKAICAICAKCgCAgCAgCgoAgIAgIAoKAICAICAKCgCAgCAgCgoAgIAgIAoKAICAICAKCgCAgCAgCgoAgIAgIAoKAICAICAKCgCAgCAgCgoAgIAgMQ0ANey9vLQJGRR2RivZGqm0B/o5wdO+NTLQA/ztUOsLPk/NVh9Fj9jmKUozLRJHCfzkEgaMRMEYtXGzKEQmpxqOtw5QWLn68XOPpjTnN97uW1heZOOJ/OQYRKA2+O4HfkJC7laruiaIKYZi31JwemeolUaTfABF/ulbRayA2K8ZEP9eR+VEaxd9OD0Xf7e5QfRY2T1S7VTKhMJJZlUrZb/S52Zjk0kirt0DGv9b2Q0Hcm+igivS3U933j/u3q2f4vR1vh6pOaF+n6M1GnOKnaF8b0C2j2jqiGIRsiaF1WeX3I6OuhJrwDlXSv6xHEA8gqCjtpxZhnsTrI0brTx/Yrr7Dzk0oYZHpHMO1tieLoazdiD7PH73P6UEod5+tVvRtz3xcvTShfSU4U/Q4cRnAqzrQ4+ctMZcYbTarEggfCoIBO5gkpX7vJbqx1kD2CsxAamX8wblpX5ooFX2+OjCw9qkHZjwVYTaBro3rGqhrs+/o97lXmpb4JPP5uEW9J2Wfq+iziqrU9I86tNK6pJsxoMPmGZz0ngNd6tvCBHhKRwF1Ynx0BMTBti5NVgKGzbpJRelARvSkcNAQdWWHj4dpkLLIHPyPL1RZN+Pa/vQVfLyut6v0GTABCLRRBifkuGOu1qXVL8cz43clh9MB3I2d5JzF3/Fn+GH7TWau6CbdgnH+FO8u7n1A/czaBBOtug3v2iS/r9ngm+R+Brw9vTyZ9wbE/0DcojezcRAF9X9SThnk4giJv/AgAVkisp/wQtx4TjkyxoD4K5CwM3Vz/GnLUGx/Ec8hsYY9Fi629yXjro5ngPhfSfvRhybbl0HK9/31f20fyNAk/n7drM9QpeST9lt6sxrQT9v2NHg54RigDTo/nwsIaFM8U38k6SPhG0hzRW9O/QQLQ5PXmiRJwAgpiGtz6zLo5JCqnliD0QH0/j0Pqsr5i81paHM1SJ8H+l1Xt5vRz6pqif9o3rLqNRQGCxaxjRPzOKEYgG5OGryty8zvQ4tfDelJtYAMQWldgAJwrdIxyDClgayU/gS8Mr9NYrWu1QItD7904Sw780RJc/ohMNrpJrWaf/3PEF00ZHujtsxdfvj1e3ergRPVPVo/eMOfyHR6D72cBDn/qudPwpP/uOs69fhAGBiwkIJaBBPaslP61xcs+a9Tec8gxAVqtW3Zjqs/cPxKzqv/KagohuI2ACY6WafNO2wDVhWqv6npfkWghz/1YWhzhF6dOWsTvCbnwsszgF4Hnvo5i6gSvDEVENfsin7VX1hkQujZ6zJKX9BBfZ9xCtty/hcTNRmqQk3q3ZgRP5SpQtaWyN/mNLwyh/iYfqOkGkLpOXdp5Xd0XHrMuTgbzfxkgnIykF63vzN+wPchN3qYAaBbgeyNgnr1dRDum53hXoSJExjvMVSpF5NEX/jULvWTE8012mgiyP28g13oVB8+WMz8253GQNWn0Yemng2S3XL+CjPXqi+MEeQ9KKroXkWLaZTuy6P5jHBrEv+AbtGnxnF6P3+3eU4nkFfouGeAhc9mXp8fvpB2QPV5A9UTPOf8hDgCFY38lSJxcRaYmVaSB+w5dw4G1ka+ZMxvlfFjwUP7ko1CRIgGY0oY87LxfjRRGcG8VJf1FXOXVv9HQ7xX4/VhEn8/vhkAEteqPu3mIkjMW5LMbWjdoI3H3NJl2cYIWuLfnbfMLKEKU8QrtOeljOybS/GX0op5TsUxn18xBrBuXLgF6AiO1HaoVye72er4pg1HAMf3IG1KAh6sMtsQAUUeG6W/mugxxwbmNihsE4irlcRFdSwXA9rYginv3ap+jjF9jj4nHHTlFj1i2EWcrc42UbKJjbUF844V7Vpjr59oYmjsaIa1vmDRXnhLlEG6wLVIc7gUBiMT3mAwFhOYw25R61ttEGemKmSU6eRF3TaNIl+U2M8CkdE7MbscBj8jGh1gUCYqoT2DWeUjre2VSxkvKTJb1QrOZJ93fDJAx1dLe3cvGIDEPR1MsIHJbTgmz+NFPRsuRzDiZa1LzZV0OeaOEmMW4AzS06V6wcqfipHghpHRril2ZKpQ1c6PSm/nPU4EVei4ZIA2TuA4MJ3fjVwfRkzp858g3d/e+ugXMp+NviJtbsu515szLXH5OoKjzx7nc+apgSVf0vcjleMwXJnMBQqhCpXTajoAzC784YvpneyGN7zH6dK0/fm4YwBKLk7fkP6/jen8GhAIH04+nTvsY7VeIdWsT/Eux6z5HKqQmwV+sFXtRxs7FMk/y061bwq9pFE56bNq4trzrh94YyGbpVBHJubi44wBjCLxEzoYnfc7c5efp8o4qWcnyEO6Aolo7y3icvSzAKq97oMb83kVwxawSX0FCceqQgbqmlZpXMpsFmJqYxAF256Cl08VwggCjc9qZEoygjuXpJWJ8vnX3H2qQpkVbvTWi1eZX8qtZzuPEGyB51GQc0/mEQpVkmlK6YCBV0i9HZmtSzm641UVOm4YgKoPsxqZ3YjndQejsDgmU++3HRjhhblCiL6qOa8MpOv5+8Jn9+Tq554HUf2Fo+c5vR0zy3ddnZr9jt/nPyyf2kg2gsIfI6ZFbJb8/Wj8lccJA0D14VIlOHTStBEux5Od4RtqfClazyR3mGcCPZtN6hXzllTesufBX8sZG1CGjE9VCtXvazETsJNDs0yhviKSbTNG1cnaNNs0CbsUTKE2p97FoQhkUkfWxiIXEMG8pZXfi8r6zyANSV1FksSGjyeFl0VHGmtDhDI0MyKtapjmRqtCenY3g33Qz3t2lL6IlIsvgvnjIG5RshIyRjObRf3JvPbqosx9i6VjjqPjOGAAZ/iCCEwU30cpiIPF4dm7Yg/LEj8k4QuwLw8h6ES8Qs0EJdgoVZRR/poto0TD+fRszALOyEey3y0gWLh8rVvUur+KDT+7mmkSRqktg2kSOd23IfoSuo1pzwA+oNT6QroKRtvFwQxfqjws7oJ2jvzL98PbsjxusfCH8Lf752hjA/hw12DGaA7ioueLUVsYxN/Dsi1bbHDMxgVCyAAUzyCOgtjA6xDR3sCOj7Zinh/UdPo7rRmA+i+NszlLDp8DeX9bUMMXy4vAk6SSavrJnq7yP4G4PpUcTv4R7kHGFJhTFOI5+8qsmUnVFNKz98zOAmEzUn037IunaRBDbodhVqRJ0GbBBNg+Z2nl7WQ4a3uEQGCS25jWDOAN3zhuYsT3JBptwDPEmKj6ME34ZzNivWbwGSXxdVAx+mz+TTjisno20iTe27qk+gHq2QsW5ajMsukVSJTbpQ4hUW7NsJS/ECobMa1ms6GGzeLjLTmCeINgTo03IYhlUkbivR9zl1TeCQP1zxC9RJ1IQMMX8hMyfh0zL6le8H/vLtUD9rqdC0zhCKZjszErq7W6j3p23iJ16xalQdxZeshUzMPWIAbhsv0AB22WCgTNG+ctS29me179DND2pDUxTRlgmARSenMm7cAAYQzfCopDGLH9Vs8ObYvnSVhexejtjDenfeZrOIfekFDE5fVspCMX0bOHimYiU7kJY6hks1UwZo05x8LO6Jiz3Myn+jndM0anJQP4iO/c9vQGSqRghi+eLYgaejmkvzJ30fzNHjAKG6FieL1Xpaod96TUoj0QQsVgK4N6NorU35pXz/ZE2dPV/D0IhHusPyicQWxrKjCzNOkks1kywTB9VaEglhwpYaIOEiGJY367mV1ViH5qPQteClJjCGZmDgzTAL7a26UvBVU6fFiMnh1kCBLZ3Pbk7tIMjSozyET4y/3vBf9y9imbSvKvPV2lX8/aYh+G7l9T+66AnitI9L1ovoM1T+dH1bSKQZBhix7sUKKAE5wOH+zpVJ/1mBRteDKuD0E0E9pvb/gmKl0P6T8roOFLKRyzdkCZBNKfOu4eEMyRxOdVIaw2uw6q0Pex5CyJv3g+foZimbOZao7fjBWfV2V9yEG0mL5IlHs71AACbatchBjSG/+KHwQEEAEuY+67YInJ1j6C7VG86YlvYVp12hu+qFh6Gwzfq2yqM1SHQLBV6PaMEvNwz45yd4QHyhSFY9p23ha4RfuNSlYwSIQjDkRcti3rzlXROsxyczjbeNXL3qnGF28QY0+Ah8FUD0FtwV4CwRjVlVCqMwbi9F52qS3MDFzj6MKdNq0YgKqPHbpS97p6WBJo8TFkkhFJamitpLY4eEdt1xNlb2f5y6il/YwjrlAGsWbgCW3OTKLkPval23qcvDrmejfun6EIMdZ8WIOS0INQFzlbhfFesYSyL8X2CPrq1nYzbUsoR33I4+I7wSdkxih2b1lmrkH6wNuGanwDdIRBL+S/m8T8v55tqtu2yBybMQ6vimGZ8dXoywuMG+D0Ma8Zo7kjf8pKKKFnx39ilyqxs079Mx0FBmMKB3aqp6G3d9jlf0P1kR434JaVUKbbuPwjBQNnziMHM7U/TY/OOnDPXmFOgc6/PnCNL/ViqjAsotnFx5Ux25G6/zGP0eXjc419ZfRNjrjYFv8XO5w713qjIr2lSN3A3t2Z2tPTGd+f9iePB3bfWpsFtthFrWemt3DQ+fKZisFV5OppwQA+96Spmq6Fnn4ml/DAoHPl0I8AVoq0AQ09eV96KH6Ev+95aXdNakKWj28U0yRMX/IY1JYS/KfH2g0j3HT8r5CObNcYVeceGqiu5/n56gZcyjSuR4rsjS45gnZTTWPkfcc86L7N1lu64/x2c4FXD8e8Zgr9OPUZANKfUzl84xdiGl/u1sQPRfx8FFgKhC/RY0/9perLDO3La1Rl6G1xqomJVyDwRB9SID3bTiSxXW49ilfMXW7eRKPcq4L10BDx47gOdJX/GbMcNwXh5WFsFs5WWG8JKmS5qpLtbLibK+DRFTsNjqnPAH7Z7jS5FxIWqkrYxa3sUwKtKaNm24dXp8FJiUei7Nmp9qKtu4MHnhDS5X5kKnWBJ+rZg/GJ2inM2yyVir4V7ttnUUNMRq2R0ce9D2InaRI3xb/Xuqz6IUYRF1weLC1l3JsXOWFKM4CVdjAAaQjqpvgySFg+MGY5FhnzEdeiJag/+EqZy8673vwKTEVEfOtTr/Z8IpOmr+7XH4Nn5Anq2RCLYSQsxgviYn3ub85blixh5wdnnSNGMs4H2Cw0iLlDJLxMt9rEtnBAUo5gl1a+qnsYG7D5TNPAIJ66DGD98Jl0RTnWBhqEAel+OLXY8H6M8H4apx8d/kPN713gibMB1v1Zwb6SsfDCXoc4YsYG0O6G8z/6ymuttyVH3YAnyt6dpU+nA8lXsEQLbQG0HERbKcE2Y93AmRWdbuSg20K4qNlQA48pywDem/CLlnSValYX2FWdUfLUICy0TaSOoiuha7+eOnO97jxPlAiifcVUk790sQHOLSEOxga4duerk3KzjQ1kjebQs/dm1A4obxxKlnOmcfGeNmHHSthU+tq5yyrvJI55bJbi3ai9hanJAM7tydUIIPVucYUujeyrLUyB9DpZpSm2Tc0nvby3KtXxzSCuF13gKZyejVpneKy4jPkf5l5TyLlvWT0Gub/RVY+F8QgBN6RdcN9kaJTxVgoRKximsCrUSKKqnQ2PPnOBk1Jp03q4PX2hS6Okf3Z3roiWufMWt64w8+wsUKeawWts4Gm7+ikaXTssNnD0CPN8pp6SEVdk63Ob8xKXz2c6+1S9HhL7CVaPofEgNgt0vhKWV0Raibpo3ouubsDt0ZBn0I2+ZsoxgDN8sbRhBUsb6g+mmFKhSTPK2tjDu/OadQsyJ2/nzbxEr+fGVs+GJdjbFX8CLsyvMrsU14fSs33gaT7qBm5jv7yqWE8fIxtZznbMBMYraKlYm6WuRsY8WRsIE7R5h68bCLJR4Ji3zPfj1GIAP2ViLKhHv4dhdk6p+Ejp1/iD+S390AaU+uCcpebNeXVY70VCpsBKeHAwlEDLFhIBBp6ytTtvnXNd/8WcBWzsok50/HU929VXYLx+FuofaYElpQEOBPEiw3ymZl83EHl3doDWQzYxpRjASzO7pn9z/BuIzjKHvbGqz3A0sxQEBHWwBoQyd/KnzMVZn7HpGaenq+nfwLmbhlZpGH6znO9tHxEbwIYfulzO9vXqyBd48rGBaqxvgvv254wNhFGF8NSwez13oYT79jLYLP+Ts062Z0POcTfosqnDAE76v/46MwsieJ3Ny88GPTHSfwhgzgKpLqnLUJ/7bgZ1vEQfOmX8d34ji76SXoe07R7q2bgqmEFssOEHyPWdWLDqauCVL/DkDOKnt6nnQLI2NoC/PNyf7EPeVzRi6wbAs5vOvcG8hns2TDVVaMowQJvzGZdL6VpMx2cxJRgAUn+e6IMMZ70itj4XIX1KdNBEfYzoiOtHW9Vh8JAtSgk4ENsXCgksWLUBjHq69/HXe489s9dZprQ2y0DyL85mCcWovtZ5dpxk66DmsavqHVM9508JBqAOSyKb295/ETq/wuq44VZ4qAcPf65dAQEa7EVzl6XL+aWvQ/Yn1PLXemngScIqDV9wRSlcthB6dn28NNK9KBxc4OkMMOrdPKctT+Cpo2Oo1jmKl1mbhTvehwriWZslW1OoSK3zSBiE+G4KMAAkrJO4WIZtI3VbyLUqaKQ4lRRDKNvnV6m18GScYSVs21dzz0ioHFkN1eqgUszBCR54ugbE9Q5ve9Q77Oy6x7myXGaztAD6cNVjpDG7phCGvY19yzWj1juoGs+fdAaweS0wkFrbq+9TpfgPIYGofkyc4Ts6UAiO0ZOhTkNw7Hae1tbWNvrZo/3iVCGUJj6DCoM7A8cGssATniKWbywUeNoze6FVe17p13fBZumFzcJkuSCxAbTjZtT4TchnupFQ5cpn4oWBj8llAGf4Wt+/0hsYQcTBBzHZ0t92BJ4MlP3BixlFS+YtMZdQcuVyObplC3t2xFtRlPJNJMtxJglCXFSFoF6xnvlXCwWerJfGND37oHoFs9RK9yxIH7hFkCPLZ0Jl2pwl5hzvhg3ScoFGJpUBvNvzpeb0Ru7izgeJsTQ+6FU7YMDHuhwjrD1t98/tzlNIYgNPj2fjUvENdsPWbJYLRVw2lwmN3dZ6fd88b3vUPszsTFs9tugh2CzqC3BA74YNRPoIwqhoR3MFD6i4J+nYZLXOdk+HOp0L9Q5qnPMnjwFcvs+8pa+cDQl7q0tGmwqqz9GQMR3Zuxz/PLLEXP8a+X4TjN5O9f9BCDvh6eIsFyhZDoGnLFluRhQ3bbYDyBV4YhnoIns5vEurMG4W0pNxw+QKuVpnuJgXwX37ntz5TLaHYV4mjQG8O8xEzeshabijC4lh0vozDpzZOjhKfWzB9eZVeSVstyOkalXfDj3bF6UEkLB2IuFexAmyet6LDfguz8uoGVGaMm0WKD+3uR0oQ7lFqVnBtKJepbace6VpsVhOYvXYpBAcdX7q00g3eDskzJU2/QDusnGIsJ6fUZIXLOjE+9p1cCC1z+nTmUG8cFYOZnWzB4tSsKXRTSxKwcGZwFKw/VTwxRKXUZuKMKov8EFsoDPtS74OtYWzQJDZCoTPPdIq8Qw9T78qvYPDXfiRoM++LgQngQGMslyPbqJiZMPg+j7h3J4JQvoxlu4jeYWSXAQ1ttmiKlrJeEXeWcAvWIUtjf6KRSkgLvYzwCzALlpGZVHKOYfj6jp+4Wdavq/5cAU+PB91Ayvs3JzZZgFUIcvrwBKsoKI1c5Zn+UyTVTcw4Qzg3V/I97kSLsa3U78GzgEMXwpSrO9T1jHScf/dDJhHHXEFkVwgBVs5BnUtRrwiK0rJqWe3OVVPxyAulDvaZLmggSd6ruIbERtYmNtz5Wudu9TX4WLdhnETXwgUizPfFznQmE2Wi2NTtjaLX2GjSKN5rp1YBnBuz/lrzEkA8i5XNRsEUQAK6aSQiw4xmCYf7v2peg+I61mXgxNAwmZ6tunnJtLxu5DgdUVePZtESYm3b5t6AlLwbpssp8OoGJZRrecKsBqzlUTR3ZFvJvR1AzOb9W1QU5/GzApBFSiIB4OYyXKqSf2uLaRHJMMLxzyEnPeaCWUA7/aEAXgrJMrrAq/vk8CVimee3rlvV9O/05iDZL3aAoNFb6FlB9Gz0QwEIsgM++fOXmxm5laFXGwA/tWN1b404CK7GaNyZuUMi1lgMXubKxPT2Szf2axeBrKrsn0YHKJ5KW7oumyRXYomozYyCdJiCSE5dErj303YzRhA4gDPbe+/AIYapn47uMwMLD5Oqj7Ye9d8a39XfBebQ4JYM1yOX4bB9Qk9Ay5HJOeDEIrfiXp2ZsTNndGU3soGixjEXGQX9LmSxisO4hGEUdFOtgGfSTe0rjK/zEzMXEE8bsYNosRy7X+DbVj/niog2g6lVrpFdvVZTSW3McgEewIniAGG8n20iun2xCZDlgVC3J8EY1UfULldNoQPuqczK+7AGv6rkev+TNDpGw/JGcSrydC5ZwESF+Ih+ztLj0ZJ+tfAhXgEUNfQChkVrmUYxKdF/Rlx2W/rfkE6uCPKuBqvxH4IL2f5TCFiA3h0vghJ6+uwyO7bvHpYdzdzXhCCAMe9dVsHJBumU25krUvx+6FPhtvPC0lbeMiQ7elWSNOvexcr8/j5/slN6iD0ouVu+sZMHkLC0oFpV3BuipHAZwHIaRAPgof1RYHLfwUNPIEJoG5ylYZrzltufovElWcW4HWsdf7Bx9V+zKF3Bo0NZN6/ivUGqixCbAXKBMUGJoABfD49mB36rssxCbWfF7IMsZ5PX3pgZpO+ncTkDTf73knY3h2lv4dO/DkrYYNkOVrJ5XZRj983b2n13WTwXK48lywH5v0RuPi2oCs403OFGYWvaZpYbwuJmUo38ann8IvsIjawBbXOzGdysYG6mxrptn7xr7cMLv41QbGBhjOAz6OfuzS5Dglbl7DMEQiECHpR9VFkqNSY1TTUrKEHQhxCGNO3W2EiLutVkLD/6ZYqGXbO0Nl1v0MPeH8Iq41FlgcfDDx1xl1IlgsYeCJEWFku25H+TdiRfhm/8M+E72s/gCVUS54Pob3M5TPRKxQGS6pssCxgC60/5wZzVl61svbxZGc2lgGg3zKPnsuaA7Tbw7o94fOHQYa6sb/bv6P0tyTAvbvfcIxxNjh9b1U/htvBL1US5qHB2e4yMRdgefAbCKn3dNX1IIYHnlIsWJWNohxGXbM9yWoboL6QuPhMPDHX009iae0rqJqg+06qnuCGUDaLX/xrVinNVparp295z20oA3jp21xJb4GL8qyAbk+WGDH3BeWGavXQ4OlZO/awxSyY9pGOvAsS9p8RIKMkO4ZZjr2yhm8MshyzltYWkVyUeJa4dqqvMVkOzO2IK4iKkWVituhTyknyMY7KF8TXMMIjTvHXlV7Wt8G+eNrNqGEi7plBbNDmh1qXVd7h85KO6EDgD41jAEhkSozzru//FUiJ5dmiUyaU2zNh8AjT5V3QnXut7k2//xhHGw1xHipl9JVvqMMWnwkwCzDNF9JwVqmadKDNfOkHuK7b9SeNEXjqS38c1HPlShOjOL6KOVgkrjyzgCfKJz+lDiKrbeWw2ACHXuzIDGJXPaZttL3RBnHjGMBBkcalDkgzTOec2IPAZbcShfT57utP01kY3QeVxoCfzEhG6e1s2gOG3MygGY4xmWaM5o78CVFN9AfOwnjxnKUDdj2hXMTlDOmntqn/RLhttUuW471GnNmO7MS4n/isK2xTR4nd2I6YjHvVCCd4/Zyqp6mav6UqCkwDrSnkVsNu0QuxFa2tx25kslxDGMBLZG6eBil2uXV7Bsn3sYQAiUvTy9zkiTo6wvAd4Ym5r/xSJS1Vu1SJiw0EYQJyE4JxJK7S3bxdN9MPcrjyfLLc/q7S/zYV87AjrjDqGg1iW9sQw9tSvYb9zOW54oXuSBK1Es/3kIsNhBEoNIi5dIBSd85vf3m2Zzh/z5B/wzMAHrrtMHupkvVO5hdXNbJR0/DViMQ+tH8ngkdQs7IkqhohcS7HvbvUIRDnGts3F4KtsYWxToNBjvWEylirZ6l5PwZv8kmuocBTGg1wBefDYCvW54bC0O3xq+6cu9i8OjdxOSy5AR/k0e3OfRuqj84gVrOqqtnGWbw9OdYDyPNbcAbwDx0JTh/Q5fit8JJQKoTQ/TPDty/tgyvfpiBkAx7Z8B0NDPvAEdpHbODz8CA9qlti9i2EhOUsYCUglilZR8nq7zVaX0b73s9s+ztb9oG41lnyD6WuUbpijzXYLGdrlKKyDwtn7clFBz7mgvSTbXAufM3VDeRSq47BYtAgjj/og3hFZ6tj7oEvcg18pIbsd076W/3XqLXuPEqFEK4Ma/iipQ09XS01Gb6j9tOvkW8qa5iRSI8Szg0xffvFa9+AOmeblpHLLYrO+JkNxHWvK6RnH2lHjTqsOn7wNcQ3tF5vXmc3BEctcB3XZ6dC9fS2jtHpcue+LeHH4jaLN4jRGoJ49/CGVqDkUCuzzo78GpQB2tZlkv6ZF1Ls5asvpI8ct+WDK3p4w/d7r+nX1oDz0idXw2767tnZvBcx0Y3MTMIRavpGbMCS6c3cKijvLEAVyhNXGsXtgQNPfsW2k5FFle2HsGBRLs7ibMV+7t/e9E1AuMnGBsLMqHwmmc3SDJul3VzNLzyN8X2IIyADZCkPzMJEdNRvxxmifUqTzPCNzBoSlJ0KazR8RwPJb4Xacord1+vJgGvka6oYEABnVHVqI695ZwGvCh3oUv8KMQjPFeAMFXii54r7IZjo6ry74nhsu53w6I91B/Yb4DqosFlCbRcLSQClyqj0dtaREJM8zgXf16P/hiBQ26YvZkAp7hXQBc+DoUpdsP5p9ege0rtiDd/kIXhGHqnb8D22veyb3ZcnZKS9HWoAkRerC4PTQuGBlGmrB1x79opfnGJnARjso3VlrO+95wpeFgaefsDcJ4jq4no2VQxub9qsXwWL8yr2IS+jRhBGTJbjOqiIDazIxmPHW1wVirDiRSZQzsH4r7X9DJgnFOaBD/P8wCT9MDXATIXLoCjwmjI7Ep6Qg0bH40Z8672PJ8z9nepRgPxp5CoRDzrg6m3q6PPhaaFHSJ/VkvzS7/DHXDUDvNCra6gbSNO0ndgGZFTMVmjPRH9cJJeJ3czWFEJq987Sw9hg5H9RaOFrMGpRLO2ANRVUkNkf8172uQWyBYIwgNfLoP60Yj2ZN1H2I+s4RNsJU28BwR1cpsOqPiAIghD8GNBrEH19PpOwLmsp/0341BPOJ9jV641s5qTZHEa+gw+cevaBneXH0sSuKURsQwSerEsUbV1w3muj89m7fLvR88ohb1yiNWMD3CMN9l+AEkpI06wVcyGNdt7N0xzfFzlCEGl08NlBNqc5mZmURXqVXWt3H08OJ9+gm41f+azJ4k0PawEMxem79wH1MzysVYGjr1Sq7APrtnpy/WnIvqfZ9VE0I9E3o/LtKbd2J50M+Q/WziOZk/k8aVo9M2toYf723Gx1AHuk2WVfMvdHbsYf3hEXrjkZzwf15NFwmht+Wt3vgzDA0F1DCCW0lhWtwKUIIyKOs3A49HUWuQzdK9w7O30zNtBV+gxiA1/Ekip05QWYvsP1kXq2tVlsEE9d7+aTYLXOypRCeOuc+5aJh6VPmr7kMahCJbBZIMIIiKdrKggD+Ok9Nk2HQaHI0CzSUVwMT4f1eJh0y77t6ht88FbvK9LsmNeCsVxsACrLsmQAZX/Z9F3YNYqWn+Gt26yBXYyBvSrUu0N9aVAVKlLrzPo4TgIUK2l0kP0sfgyt7oDVvpdDFYIYCxbJpt+K/wuplMPHGIQBup0b7MnToqcB6T7qvjhySmtTpUuS7rTkVH0bGyrk82cDtRx++kZoXyt9w7DQfp5x8Bp4LwCC1t/i7YepibX0ZtRzuh3WAyW9GqrQPmKFu+SfrSisTFpNSgMvj3rTOn8go1JouWVf7gwQyUZZp+3E93u6ov181+1wsN8WeAnCAH565l9I/0ddZyE965wKMtXH9gk1vu1Pdag+a/gW9PnXio9PRMPqyH+Bsr8v2Ok7X1CHOe3MWXouVdH/5f29O7PWvox6HrCgQWxdjlpd5cJ3UNlyVWahn3xG6sDMWU3f5z1DCRsfye7pjDcCy8ezEso8zgVLQ1jtD71U0W682lpv0tqoGNXxQxgGGA5cWT+A9AKuHADJZDe7qL07WYE7A0kP9Owof4UPurGqz9FdG0pEQ5bjRzF9v0CvEM6CLK/1sA8Mi2fZ83cxtdkycUDvVbdL7YZn7F9A9+tc9LWOPg6OBa5avjc7GA8JK2yGItk6rbpItrWt6iBcYmlQMG/rvn+c9v1iF3vr9zXj+6JHMAYgR5Jge+9XP4TUW4vtpnFYLq31wfRzoFB99h/u0zY876uPig6ynus9cT21S/0EyvG1LpuVT6KWBwfVx/SBIJuSvuSbvZ16A+/tpWE9/RjvXC+pIWE7oAp1Y7YiKVv9eLxr8TtVtAEsUAtVM/kcF8HlNaGFjcdy386mb2A1sXtdDQYN4hrVSjNgbTGcnZr0w/sfPOUXpLEI+5qxvyGOcAyA3nR3QFIiQLG/M94OQt4BgEuYCai90V3H/2QGdp7/+R66q/2eC1s18xtl9J9zl5LQUhP3qfkYMjaxmkQlvQ/j4Lor3LdsAJzAPqd4hNk/Pxal+GCxOp1uQcSyt2Ti91mvlY0AFzN+R+w4VQAXXU61+gBmq+fABHRBkwmO7OORfbXPAmOCsDFfRlbsFbZ9eMFGvE/BLwcZ9Sd6LXD5D9yXopFYVSyCtn3KF//fMoelC9BEkzPQ/5QxEBI/mcpeEugl8KDxoNdlij+kylIMeBnKBQ+CKDAUZMprVg6RmDTsTCwyW9IlSi7W6KYV83Rqkj/qQU0sBxpaGtWLV3dG2BHGsQaE8n9IMOxpFNOtZxkie2ZwcXAsSFDg79zF/ZFyqn/9yR3qWSutAqo+x4zBGu6Pl+l3T0z1Urhwn0A/m4nrEX0cpC1o/DCaM+JPP9/bpf/Atmmlahid+pg+klHZPvoal/T7gOW/gR741OHWtmeDIVn+4v4jl5z9J81gl5onMAO/FTbZQ40gft4968IxvS74hQ9Tw2+P6PDZoKVrIQ3fhdnhPMxmrwaPk/GwJKD6MX7bg/ePHO6P/4aS30q1RhJNPUOjVOQDRCrW3KXRhxGOvBx9/lU0cQZsgww7/mrSl/D91xCwfJDbC/EWjXpgI3Xf3wurb8xoqaY3I771p3ButkaajDB0BWwrrkl+AI99G5aN7LK/cBaZCLz9fYDpvJ+n10GyL4bguNjZSoOdpCkPRu7BpLVzxql6F20TP77BkwK+GQZPwFZdU0d3fH67mV3VA6cgXhBjnIeak+intjprlPPD9yhHi4NMkF17/kpzGtybZydJdBrcPDEY+lApKh2gxM/OQLR3ERh8Iohq2HCGY82dV0onRXNBZGcqVS0lVNhwlMql519+JfqBFTT84qix8auGHp4JeBO8n3Nm9a2YPn8LnZsD3SEG0yKZLvqnwwPxP/g+Dh9XQ/vWqMY5AP4ftX08BKvvE5ypevg+jrmimlF2HGOe0+ABAsMxsXa3t+f4WbrBXTqm+UEsj/nliC8yj1Rj7JLhN2roDDD8RjSOrX3gIq5Ic+QSZSbqoHRqgJF4xM1DfcAYOqBUDI7Btct1QafSOCjZj+6jh8D2tUH6vr9HLX9dH0eq9e2m/WVVz1oaknMEAUFAEBAEBAFBQBAQBAQBQUAQEAQEAUFAEBAEBAFBQBAQBAQBQUAQEAQEAUFAEBAEBAFBQBAQBAQBQUAQEAQEAUFAEBAEBAFBQBAQBAQBQUAQEAQEAUFAEBAEBAFBQBAQBAQBQUAQEAQEAUFAEBAEBAFBQBAQBAQBQUAQEAQEAUFAEBAEBAFBQBAQBAQBQUAQEAQEAUFAEBAEBAFBQBAQBAQBQUAQEAQEAUFAEBAEBAFBQBAQBAQBQUAQEAQEAUFAEBAEBAFBQBAQBAQBQUAQEAQEAUFAEBAEBAFBQBAQBAQBQUAQEAQEAUFAEBAEBAFBQBAQBAQBQUAQEAQEgYAI/DcCujEzYbMTtwAAAABJRU5ErkJggg==";
var MSafeWalletName = "MSafe";
var MSafeWalletAdapter = class {
  constructor(origin) {
    this.name = MSafeWalletName;
    this.icon = `data:image/png;base64,${LOGO_PNG_BASE64}`;
    this.provider = void 0;
    this._origin = origin;
    if (MSafeWallet.inMSafeWallet()) {
      MSafeWallet.new(origin).then((msafe) => {
        window.msafe = this.provider = toPluginProvider(msafe);
      }).catch((e) => {
        console.error("MSafe connect error:", e);
      });
    }
  }
  get url() {
    const defaultOrigin = this._origin instanceof Array ? this._origin[0] : this._origin;
    if (typeof window === "undefined" || typeof window.location === "undefined" || typeof window.location.href === "undefined")
      return MSafeWallet.getOrigin(defaultOrigin);
    return MSafeWallet.getAppUrl(defaultOrigin);
  }
  async connect() {
    var _a;
    try {
      const accountInfo = await ((_a = this.provider) == null ? void 0 : _a.connect());
      if (!accountInfo)
        throw `${MSafeWalletName} Address Info Error`;
      return accountInfo;
    } catch (error) {
      throw error;
    }
  }
  async account() {
    var _a;
    const response = await ((_a = this.provider) == null ? void 0 : _a.account());
    if (!response)
      throw `${MSafeWalletName} Account Error`;
    return response;
  }
  async disconnect() {
    var _a;
    try {
      await ((_a = this.provider) == null ? void 0 : _a.disconnect());
    } catch (error) {
      throw error;
    }
  }
  async signAndSubmitTransaction(transaction, options) {
    var _a;
    try {
      const response = await ((_a = this.provider) == null ? void 0 : _a.signAndSubmitTransaction(
        transaction,
        options
      ));
      if (response.code) {
        throw new Error(response.message);
      }
      return response;
    } catch (error) {
      const errMsg = error.message;
      throw errMsg;
    }
  }
  async signMessage(message) {
    var _a;
    try {
      if (typeof message !== "object" || !message.nonce) {
        `${MSafeWalletName} Invalid signMessage Payload`;
      }
      const response = await ((_a = this.provider) == null ? void 0 : _a.signMessage(message));
      if (response) {
        return response;
      } else {
        throw `${MSafeWalletName} Sign Message failed`;
      }
    } catch (error) {
      const errMsg = error.message;
      throw errMsg;
    }
  }
  async network() {
    var _a;
    try {
      const response = await ((_a = this.provider) == null ? void 0 : _a.network());
      if (!response)
        throw `${MSafeWalletName} Network Error`;
      return {
        name: response
      };
    } catch (error) {
      throw error;
    }
  }
  async onNetworkChange(callback) {
    var _a;
    try {
      const handleNetworkChange = async (newNetwork) => {
        callback({
          name: newNetwork.networkName,
          chainId: void 0,
          api: void 0
        });
      };
      await ((_a = this.provider) == null ? void 0 : _a.onNetworkChange(handleNetworkChange));
    } catch (error) {
      const errMsg = error.message;
      throw errMsg;
    }
  }
  async onAccountChange(callback) {
    var _a;
    try {
      const handleAccountChange = async (newAccount) => {
        if (newAccount == null ? void 0 : newAccount.publicKey) {
          callback({
            publicKey: newAccount.publicKey,
            address: newAccount.address
          });
        } else {
          const response = await this.connect();
          callback({
            address: response == null ? void 0 : response.address,
            publicKey: response == null ? void 0 : response.publicKey
          });
        }
      };
      await ((_a = this.provider) == null ? void 0 : _a.onAccountChange(handleAccountChange));
    } catch (error) {
      console.log(error);
      const errMsg = error.message;
      throw errMsg;
    }
  }
};
export {
  MSafeWalletAdapter,
  MSafeWalletName
};
//# sourceMappingURL=msafe-plugin-wallet-adapter.js.map
